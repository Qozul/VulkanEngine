#version 450
#extension GL_GOOGLE_include_directive : enable
#include "./alt_functions.glsl"

#define TOTAL_INVOCATIONS vec2(63.0, 255.0)
#define INTEGRATION_STEPS_TRANSMITTANCE 200

layout(local_size_x = INVOCATION_SIZE, local_size_y = INVOCATION_SIZE, local_size_z = 1) in;

layout(binding = 0) uniform Params {
	AtmosphereParameters atmosphere;
};
layout(binding = 1, rgba32f) uniform restrict writeonly image2D transmittanceTexture;

// Produces transmittance between integral point and atmosphere
void main()
{
	float height = UhToHeight(gl_GlobalInvocationID.x / TOTAL_INVOCATIONS.x, atmosphere.Hatm);
	float Cv = UvToCv(gl_GlobalInvocationID.y / TOTAL_INVOCATIONS.y, height, atmosphere.planetRadius);

	vec2 Pa = vec2(height + atmosphere.planetRadius, 0.0);
	
	vec2 v = getRay(Cv);
	
    float t = distanceToCircle(Pa, v, atmosphere.planetRadius + atmosphere.Hatm, false);
	int numSteps = isinf(t) ? 0 : INTEGRATION_STEPS_TRANSMITTANCE;
	
    vec2 Pb = Pa + t * v;
	
	float mieDensitySum = 0.0;
	float rayleighDensitySum = 0.0;
	float ozoneDensitySum = 0.0;
	float previousMieDensity = 0.0;
	float previousRayleighDensity = 0.0;
	float previousOzoneDensity = 0.0;
	// Integrate along viewing ray from corresponding height
	float stepSize = distance(Pa, Pb) / float(INTEGRATION_STEPS_TRANSMITTANCE);
	// For each integration step, calculate the particle density of Mie and Rayleigh
	for (int s = 0; s < numSteps; ++s) {
		vec2 P = Pa + stepSize * s * v; // Integration point
		float h = getHeight(P, atmosphere.planetRadius);
		float mieDensity = getDensity(h, atmosphere.mieScaleHeight);
		float rayleighDensity = getDensity(h, atmosphere.rayleighScaleHeight);
		float ozoneDensity = 6e-7 * rayleighDensity;
		mieDensitySum += (mieDensity + previousMieDensity) / 2.0 * stepSize;
		rayleighDensitySum += (rayleighDensity + previousMieDensity) / 2.0 * stepSize;
		ozoneDensitySum += (ozoneDensity + previousOzoneDensity) / 2.0 * stepSize;
		previousMieDensity = mieDensity;
		previousRayleighDensity = rayleighDensity;
		previousOzoneDensity = ozoneDensity;
	}
	vec3 result = isinf(t) ?  vec3(1.0) :  exp(-(atmosphere.betaRay * rayleighDensitySum + 
		atmosphere.betaMieExt * mieDensitySum + atmosphere.betaOzoneExt * ozoneDensitySum ));
	
	imageStore(transmittanceTexture, ivec2(gl_GlobalInvocationID.xy), vec4(result, 1.0));
}
