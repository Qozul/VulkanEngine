// Compute shader with x,y in
// Runs as a post-pass after the main stuff has been calculated, uses depth and colour 
// texture from previous render pass(es) as attachments. Calculates the aerial perspective
// from x,y to point p at depthBuffer(x,y).
// In the following post processing render pass the colour aerial perspective are mixed.
#version 450
#extension GL_GOOGLE_include_directive : enable
#include "./alt_functions.glsl"

const vec2 totalInvocations = vec2(31, 31);
const float NUM_STEPS = 16.0;
const float STEP_SIZE = 1.0 / 16.0;

layout(local_size_x = INVOCATION_SIZE, local_size_y = INVOCATION_SIZE, local_size_z = 1) in;

// 84B, 16-byte aligned
layout(push_constant) uniform Ubo {
	vec3 camPos;
	float padding1;
	vec3 zenithDir;
	float cameraHeight;
	vec3 sunDir;
	float padding;
	mat4 inverseViewProj;
};

layout (binding = 0) uniform Params {
	AtmosphereParameters atmosphere;
};

layout(binding = 1, rgba16f) uniform writeonly image3D aerialPerspectiveTexture;
//layout(binding = 2) uniform sampler2D gatheringSum;

void main()
{
	// uv in range [0, 1]
	vec2 uv =  gl_GlobalInvocationID.xy / totalInvocations.xy;
	vec3 Pa = getNearPlaneWorldPosition(uv, inverseViewProj);
	
	vec3 V = normalize(camPos - Pa);
	vec3 L = sunDir;
	
	float mieDensitySum = 0.0;
	float rayleighDensitySum = 0.0;
	float ozoneDensitySum = 0.0;
	float previousMieDensity = 0.0;
	float previousRayleighDensity = 0.0;
	float previousOzoneDensity = 0.0;
	
	vec3 transmittance = vec3(0.0);
	float currentInscatteringMie = 0.0;
	vec3 currentInscatteringRayleigh = vec3(0.0);

	float previousInscatteringMie = 0.0;
	vec3 previousInscatteringRayleigh = vec3(0.0);

	float totalInscatteringMie = 0.0;
	vec3 totalInscatteringRayleigh = vec3(0.0);

	float completedInscatteringMie = 0.0;
	vec3 completedInscatteringRayleigh = vec3(0.0);
	for (int s = 0; s < NUM_STEPS; ++s) {
		vec3 P = Pa + STEP_SIZE * s * V;
		float h = clamp(P.y, 0.0, atmosphere.Hatm);
		
		float mieDensity = getDensity(h, atmosphere.mieScaleHeight);
		float rayleighDensity = getDensity(h, atmosphere.rayleighScaleHeight);
		float ozoneDensity = 6e-7 * rayleighDensity;

		mieDensitySum += (mieDensity + previousMieDensity) / 2.0 * STEP_SIZE;
		rayleighDensitySum += (rayleighDensity + previousRayleighDensity) / 2.0 * STEP_SIZE;
		ozoneDensitySum += (ozoneDensity + previousOzoneDensity) / 2.0 * STEP_SIZE;

		previousMieDensity = mieDensity;
		previousRayleighDensity = rayleighDensity;
		
		//vec4 gathered = texture(gatheringSum, vec2(h, CsToUs(dot(L, zenithDir))));
		transmittance = exp(-(rayleighDensitySum * atmosphere.betaRay.rgb + mieDensitySum * atmosphere.betaMieExt));
		transmittance *= exp(-(atmosphere.betaRay * rayleighDensitySum + 
			atmosphere.betaMieExt * mieDensitySum + atmosphere.betaOzoneExt * ozoneDensitySum ));
		
		currentInscatteringMie = mieDensity * transmittance.r;
		currentInscatteringRayleigh = rayleighDensity * transmittance;
		
		totalInscatteringMie += (currentInscatteringMie + previousInscatteringMie) / 2.0 * STEP_SIZE;
		totalInscatteringRayleigh += (currentInscatteringRayleigh + previousInscatteringRayleigh) / 2.0 * STEP_SIZE;
		
		previousInscatteringMie = currentInscatteringMie;
		previousInscatteringRayleigh = currentInscatteringRayleigh;
		previousOzoneDensity = ozoneDensity;
		
		completedInscatteringMie = totalInscatteringMie;
		completedInscatteringRayleigh = totalInscatteringRayleigh;
		completedInscatteringMie *= atmosphere.betaMie / (4.0 * PI);
		completedInscatteringRayleigh *= atmosphere.betaRay / (4.0 * PI);
		
		imageStore(aerialPerspectiveTexture, ivec3(gl_GlobalInvocationID.xy, s), vec4(completedInscatteringRayleigh.rgb, completedInscatteringMie));
	}
}
